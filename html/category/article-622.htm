<!DOCTYPE html>
<html lang="zh-CN">

<head>
        <link rel="canonical" href="https://finlandaddress.github.io/html/category/article-622.htm" />
    <title>React-class——React表单与事件（受控组件与非受控组件、事件类型、事件对象、事件绑定）、React组件生命周期、面试 - FinlandAddress</title>
        <meta charset="utf-8">
    <link rel="icon" href="/assets/addons/xcblog/img/finlandaddress/favicon.ico" type="image/x-icon"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600;700&display=swap" rel="stylesheet" />
    <link href="https://fonts.googleapis.com/css2?family=Raleway:wght@400;500;600;700;800;900&display=swap" rel="stylesheet" />
    <link href="/assets/addons/xcblog/css/finlandaddress/font-awesome.min.css" rel="stylesheet" />
    <link href="/assets/addons/xcblog/css/finlandaddress/animate.css" rel="stylesheet" />
    <link href="/assets/addons/xcblog/css/finlandaddress/owl.carousel.min.css" rel="stylesheet" />
    <link href="/assets/addons/xcblog/css/finlandaddress/owl.theme.default.min.css" rel="stylesheet" />
    <link href="/assets/addons/xcblog/css/finlandaddress/magnific-popup.css" rel="stylesheet" />
    <link href="/assets/addons/xcblog/css/finlandaddress/flaticon.css" rel="stylesheet" />
    <link href="/assets/addons/xcblog/css/finlandaddress/style.css" rel="stylesheet" />
    <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?a045e5bb3ae69629060e7ce2a4b98902";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3332997411212854"
     crossorigin="anonymous"></script>
</head>

<body>
        <nav class="navbar navbar-expand-lg navbar-dark ftco_navbar ftco-navbar-light site-navbar-target" id="ftco-navbar">
        <div class="container">
                        <a class="navbar-brand" href="/">Finland Address<span></span></a>
            
            <button class="navbar-toggler js-fh5co-nav-toggle fh5co-nav-toggle" type="button" data-toggle="collapse" data-target="#ftco-nav" aria-controls="ftco-nav" aria-expanded="false" aria-label="Toggle navigation">
                <span class="oi oi-menu"></span> MENU
            </button>
            <div class="collapse navbar-collapse" id="ftco-nav">
                <ul class="navbar-nav nav ml-auto">
                	                    <li class="nav-item"><a href="/xcblog/" class="nav-link"><span>首页</span></a></li>
                                        <li class="nav-item"><a href="/html/category/" class="nav-link"><span>文章分类</span></a></li>
                                        <li class="nav-item"><a href="#" class="nav-link"><span>关于</span></a></li>
                    <li class="nav-item"><a href="#" class="nav-link"><span>联系</span></a></li>
                </ul>
            </div>
        </div>
    </nav>
    <section class="hero-wrap" style="height:350px;overflow: hidden;">
        <div class="overlay"></div>
        <div class="container-fluid px-0">
            <div class="row d-md-flex no-gutters slider-text align-items-center js-fullheight justify-content-end">
                <img class="one-third js-fullheight align-self-end order-md-last img-fluid" src="/assets/addons/xcblog/img/finlandaddress/undraw_book_lover_mkck.svg" alt="" style="opacity: 0.5;">
                <div class="one-forth d-flex align-items-center ftco-animate js-fullheight">
                    <div class="text" style="top: 30%;min-width: 70%;">
                        <h1>React-class——React表单与事件（受控组件与非受控组件、事件类型、事件对象、事件绑定）、React组件生命周期、面试</h1>
                        <p>
                            <a href="/">首页</a> / <a href="/html/category/">文章分类</a> / <span>正文</span>
                        </p>
                    </div>
                </div>
            </div>
        </div>
    </section>
    <section class="ftco-about img ftco-section" id="about-section">
        <div class="container">
            <div class="row">
                <div class="col-md-9">
                	  				  				  				<div id="content_views" class="htmledit_views"> <p id="main-toc"><strong>目录</strong></p> <p id="%E4%B8%80%E3%80%81React%E8%A1%A8%E5%8D%95%E4%B8%8E%E4%BA%8B%E4%BB%B6-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81React%E8%A1%A8%E5%8D%95%E4%B8%8E%E4%BA%8B%E4%BB%B6" rel="nofollow">一、React表单与事件</a></p> <p id="1%E3%80%81React%E8%A1%A8%E5%8D%95%E7%BB%84%E4%BB%B6-toc" style="margin-left:40px;"><a href="#1%E3%80%81React%E8%A1%A8%E5%8D%95%E7%BB%84%E4%BB%B6" rel="nofollow">1、React表单组件</a></p> <p id="%EF%BC%881%EF%BC%89%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E4%B8%8E%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E2%80%94%E2%80%94%E7%AC%94%E8%AF%95%E9%A2%98-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E4%B8%8E%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E2%80%94%E2%80%94%E7%AC%94%E8%AF%95%E9%A2%98" rel="nofollow">（1）受控组件与非受控组件——笔试题</a></p> <p id="%EF%BC%882%EF%BC%89%E6%9B%B4%E5%A4%9A%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89%E6%9B%B4%E5%A4%9A%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6" rel="nofollow">（2）更多受控组件</a></p> <p id="2%E3%80%81React%E4%BA%8B%E4%BB%B6-toc" style="margin-left:40px;"><a href="#2%E3%80%81React%E4%BA%8B%E4%BB%B6" rel="nofollow">2、React事件</a></p> <p id="%EF%BC%881%EF%BC%89%E4%BA%8B%E4%BB%B6%E7%B1%BB%E5%9E%8B-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89%E4%BA%8B%E4%BB%B6%E7%B1%BB%E5%9E%8B" rel="nofollow">（1）事件类型</a></p> <p id="%EF%BC%882%EF%BC%89%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1" rel="nofollow">（2）事件对象</a></p> <p id="%EF%BC%883%EF%BC%89%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E2%80%94%E2%80%94this%E4%B8%BAunde-toc" style="margin-left:80px;"><a href="#%EF%BC%883%EF%BC%89%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E2%80%94%E2%80%94this%E4%B8%BAunde" rel="nofollow">（3）事件绑定——this为unde</a></p> <p id="%E4%BA%8C%E3%80%81React%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81React%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" rel="nofollow">二、React组件生命周期</a></p> <p id="%C2%A01%E3%80%81%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-toc" style="margin-left:40px;"><a href="#%C2%A01%E3%80%81%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" rel="nofollow">&nbsp;1、组件的生命周期</a></p> <p id="%C2%A02%E3%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%E8%AF%A6%E8%A7%A3-toc" style="margin-left:40px;"><a href="#%C2%A02%E3%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%E8%AF%A6%E8%A7%A3" rel="nofollow">&nbsp;2、生命周期钩子详解</a></p> <p id="-%20**componentWillMount**%20%EF%BC%9A-toc" style="margin-left:80px;"><a href="#-%20**componentWillMount**%20%EF%BC%9A" rel="nofollow">- **componentWillMount** ：</a></p> <p id="-%20**componentDidMount**%20%3A-toc" style="margin-left:80px;"><a href="#-%20**componentDidMount**%20%3A" rel="nofollow">- **componentDidMount** :</a></p> <p id="-%20**componentWillReceiveProps**%20%3A-toc" style="margin-left:80px;"><a href="#-%20**componentWillReceiveProps**%20%3A" rel="nofollow">- **componentWillReceiveProps** :</a></p> <p id="-%20**shouldComponentUpdate**%20%3A-toc" style="margin-left:80px;"><a href="#-%20**shouldComponentUpdate**%20%3A" rel="nofollow">- **shouldComponentUpdate** :</a></p> <p id="-%20**componentWillUpdate**%3A-toc" style="margin-left:80px;"><a href="#-%20**componentWillUpdate**%3A" rel="nofollow">- **componentWillUpdate**:</a></p> <p id="-%20**componentDidUpdate**%20%3A-toc" style="margin-left:80px;"><a href="#-%20**componentDidUpdate**%20%3A" rel="nofollow">render函数 在这中间执行</a></p> <p id="-%20**componentDidUpdate**%20%3A-toc" style="margin-left:80px;"><a href="#-%20**componentDidUpdate**%20%3A" rel="nofollow">- **componentDidUpdate** :</a></p> <p id="-%20**componentWillUnmount**%3A-toc" style="margin-left:80px;"><a href="#-%20**componentWillUnmount**%3A" rel="nofollow">- **componentWillUnmount**:</a></p> <p id="%C2%A03%E3%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-toc" style="margin-left:40px;"><a href="#%C2%A03%E3%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82" rel="nofollow">&nbsp;3、生命周期钩子——网络请求</a></p> <hr id="hr-toc"/> <h1 id="%E4%B8%80%E3%80%81React%E8%A1%A8%E5%8D%95%E4%B8%8E%E4%BA%8B%E4%BB%B6">一、React表单与事件</h1> <h2 id="1%E3%80%81React%E8%A1%A8%E5%8D%95%E7%BB%84%E4%BB%B6">1、React表单组件</h2> <blockquote> <p>在HTML中，表单元素与其他元素最大的不同是它自带值或数据</p> <p>而且，只要是有表单出现的地方，就会有用户输入，表单事件触发，就会涉及的数据处理。</p> <p>在我们用React开发应用时，为了更好地管理应用中的数据，响应用户的输入，编写组件的时候呢，我们就会运用到**<strong>受控组件与非受控组件</strong>**这两个概念。</p> <p>React推荐我们在绝大多数情况下都使用受控组件。这样可以保证表单的数据在组件的state管理之下，而不是各自独立保有各自的数据。</p> </blockquote> <h3></h3> <h3 id="%EF%BC%881%EF%BC%89%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E4%B8%8E%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E2%80%94%E2%80%94%E7%AC%94%E8%AF%95%E9%A2%98"><span style="color:#956fe7;">（1）受控组件与非受控组件——笔试题</span></h3> <p><span style="color:#a5a5a5;">没有v-model，需要自己去实现</span></p> <blockquote> <p>**受控组件**简单来说就是它的值由React进行管理，</p> <p>而**非受控组件**的值则由原生DOM进行管理。</p> <p><strong>- 受控组件：</strong>==&gt;双向</p> <p>一般涉及到表单元素时我们才会使用这种分类方法。</p> <p>受控组件的值由props或state传入给受控组件（表单的输入框），用户在元素上交互或输入内容会引起应用state的改变。</p> <p>在state改变之后重新渲染组件，我们才能在页面中看到元素中值的变化，</p> <p><strong>假如组件没有绑定事件处理函数改变state，用户的输入是不会起到任何效果的</strong>，这也就是“受控”的含义所在。</p> <p><strong>- 非受控组件：</strong>==&gt;单向</p> <p>类似于传统的DOM表单控件，用户输入不会直接引起应用state的变化，我们也不会直接为非受控组件传入值。</p> <p>&nbsp;想要获取非受控组件，我们需要使用一个特殊的ref属性，同样也可以使用defaultValue属性来为其指定一次性的默认值。</p> </blockquote> <p>示例如下：</p> <pre><code class="language-javascript">import React from "react" class App extends React.Component {     constructor(arg) {         super(arg)         this.state = {}         this.handleChange = (e) =&gt; {             this.setState({ value: e.target.value });             // e.target.value就是输入的值         }     }     render() {         return (             &lt;div&gt;                 {/* 1、受控组件 */}                 &lt;input type='text' value={this.state.value} onChange={this.handleChange} /&gt;                  {/* 2、非受控组件 */}                 &lt;input type="text" value={this.state.value} /&gt;                 {/* 如果上没有onChange事件，输入框不能输入，value会一直是this.state.value */}                 &lt;input type="text" defaultValue="hello!" /&gt;             &lt;/div&gt;         )     } } export default App</code></pre> <h3 id="%EF%BC%882%EF%BC%89%E6%9B%B4%E5%A4%9A%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6">（2）更多受控组件</h3> <p>在组件中声明表单元素（input_type/checked &nbsp; textarea &nbsp;select ……）时，一般都要为表单元素传入应用状态中的值，我们需要根据表单元素中用户的输入，对应用数据进行相应的操作和改变。</p> <p><strong>1、radio：</strong></p> <pre><code class="language-javascript">class MyApp extends React.Component { 	constructor(props) { 		super(props); 		this.state = { 			gender: '' 		};         this.handleGender = this.handleGender.bind(this); 	}     handleGender(event) { 		this.setState({gender: event.target.value}); 	}  	render() { 		return ( 			&lt;div&gt;                 &lt;h2&gt;input_checked 受控组件&lt;/h2&gt;                 &lt;input type='radio' value="man" checked={this.state.gender=='man'} onChange={this.handleGender}/&gt;男&lt;br /&gt;                 &lt;input type='radio' value="woman" checked={this.state.gender=='woman'} onChange={this.handleGender}/&gt;女&lt;br /&gt; 				&lt;div&gt;{this.state.gender}&lt;/div&gt;                  			&lt;/div&gt; 		); 	} }  ReactDOM.render( 	&lt;MyApp /&gt;, 	document.getElementById('root') );</code></pre> <p><strong>2、mycheck:</strong></p> <pre><code class="language-javascript">import React, { Component } from 'react' export default class Mycheck extends Component {     constructor(){         super()         this.state={             chengdu:true         }         this.chengduchange=(e)=&gt;{            console.log(e.target.checked)            this.state.chengdu=e.target.checked            this.setState(this.state)         }     }   render() {     return (       &lt;div&gt;         &lt;input type="checkbox" name='city' value="chengdu" checked={this.state.chengdu} onChange={this.chengduchange}/&gt;         &lt;input type="checkbox" name='city' value="shanghai"/&gt;         &lt;input type="checkbox" name='city' value="beijing"/&gt;         &lt;input type="checkbox" name='city' value="tianjing"/&gt;       &lt;/div&gt;     )   } } </code></pre> <p><strong>3、mydata</strong></p> <pre><code class="language-javascript">import React, { Component } from 'react' export default class Mydate extends Component {     constructor(){         super()         this.state={             v:"2021-11-11"         }         this.change1=(e)=&gt;{               console.log(e.target.value)               this.state.v=e.target.value               this.setState(this.state)         }     }   render() {     return (       &lt;div&gt;         &lt;input type="date" value={this.state.v} onChange={this.change1}/&gt;       &lt;/div&gt;     )   } } </code></pre> <p><strong>4、myfile</strong></p> <pre><code class="language-javascript">import React, { Component } from 'react' export default class Myfile extends Component {     constructor(){         super()         this.state={             v:""         }         this.change1=(e)=&gt;{             console.log(e.target.files[0])            this.state.v=e.target.files[0]            this.setState(this.state)         }     }   render() {     return (       &lt;div&gt;         &lt;input type="file" onChange={this.change1}/&gt;       &lt;/div&gt;     )   } } </code></pre> <p><strong>5、myselect</strong></p> <pre><code class="language-javascript">import React, { Component } from 'react' export default class Myselect extends Component {     constructor(){         super()         this.state={             v:"beijing"         }         this.change1=(e)=&gt;{           console.log(e.target.value)           this.state.v=e.target.value           this.setState(this.state)         }         this.send=()=&gt;{           console.log(this.state.v)         }     }   render() {     return (       &lt;div&gt;         &lt;select name="city" value={this.state.v} onChange={this.change1}&gt;             &lt;option value="chengdu"&gt;成都&lt;/option&gt;             &lt;option value="beijing"&gt;北京&lt;/option&gt;             &lt;option value="shanghai"&gt;上海&lt;/option&gt;         &lt;/select&gt;         &lt;button onClick={this.send}&gt;发送&lt;/button&gt;       &lt;/div&gt;     )   } } </code></pre> <p><strong>7、mytext</strong></p> <pre><code class="language-javascript">import React, { Component } from 'react' export default class Mytext extends Component {     constructor(arg){         super(arg)         this.state={msg:"66666"}         this.input1=(e)=&gt;{           console.log(e.target.value)           this.state.msg=e.target.value           this.setState(this.state)         }       }     render() {         return (             &lt;div&gt;                 &lt;p&gt;{this.state.msg}&lt;/p&gt;                 &lt;input type="text" value={this.state.msg} onInput={this.input1} /&gt;                 &lt;input type="text" /&gt;             &lt;/div&gt;         )     } } </code></pre> <h2 id="2%E3%80%81React%E4%BA%8B%E4%BB%B6">2、React事件</h2> <h3 id="%EF%BC%881%EF%BC%89%E4%BA%8B%E4%BB%B6%E7%B1%BB%E5%9E%8B">（1）事件类型</h3> <p>使用React元素处理事件与处理DOM元素上的事件非常相似。不过有一些语法上的差异：</p> <blockquote> <p>- React事件使用**<strong>小驼峰命名法</strong>**，而不是全部小写命名。<br /> - React事件使用JSX传递一个函数作为事件处理程序，而不是一个字符串。</p> <p>示例：</p> <p>- 鼠标事件：onClick &nbsp; onDoubleClick &nbsp;onMouseDown<br /> - 触摸事件：onTouchStart &nbsp; onTouchMove &nbsp; onTouchEnd&nbsp;<br /> - 键盘事件：onKeyDown&nbsp;<br /> - 剪切事件：onCopy &nbsp; onCut &nbsp; &nbsp; onPaste&nbsp;<br /> - 表单事件：onChange &nbsp; &nbsp;onInput &nbsp; onSubmit&nbsp;<br /> - 焦点事件：onFocus&nbsp;<br /> - UI事件：onScroll&nbsp;<br /> - 滚动事件：onWheel</p> </blockquote> <h3></h3> <h3 id="%EF%BC%882%EF%BC%89%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1">（2）事件对象</h3> <p>构造函数：fun</p> <blockquote> <p>- React对原生的事件系统也进行了封装，在React中的事件对象实际上是一个跨浏览器的**虚拟事件对象** ，它拥有和原生事件对象相同的属性和方法。</p> <p><strong>- 在react 中使用“return false” 无法阻止默认事件，只能通过事件对象调用“event.preventDefault() ”进行阻止</strong></p> </blockquote> <pre><code class="language-javascript">class ClickEvent extends React.Component { 	constructor(props) { 		super(props); 		this.state = { 			value: 'hello world' 		};         //函数写法==&gt; 方法1： 		this.changeData = this.changeData.bind(this);         //方法2：         this.fm=()=&gt;{} 	}      //方法3： 	changeData(event) { //changeData函数也可以写在构造函数constructor内，写this.changeData都能调用到这个给函数         console.log(event) 		this.setState({value: '萨瓦迪卡'}); 	}     fn(arg){}     //方法4：     fn1=function(){}     //方法5：     fn2=（）=&gt;{} 	render() { 		return ( 			&lt;div&gt; 				&lt;button onClick={this.changeData}&gt;点击改变&lt;/button&gt; 				&lt;h2&gt;{this.state.value}&lt;/h2&gt;                  //方法6：因为react中函数不能写小括号，所以自己设计，去实现有小括号，传参                 &lt;button onClick={(e)=&gt;{this.fn(100)}}&gt;函数传参&lt;/button&gt; 			&lt;/div&gt; 		); 	} }</code></pre> <h3></h3> <h3 id="%EF%BC%883%EF%BC%89%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E2%80%94%E2%80%94this%E4%B8%BAunde">（3）事件绑定——this为unde</h3> <p>事件处理函数内部使用this 关键词时其指向==&gt;</p> <pre><code class="language-javascript">class ClickEvent extends React.Component {     constructor(arg) {         super(arg)         this.changeData=function (){console.log(this);}  //undefined     } 	changeData() {         console.log(this);//undefined 	} 	render() { 		return ( 			&lt;div&gt; 				&lt;button onClick={this.changeData}&gt;点击改变&lt;/button&gt; 			&lt;/div&gt; 		); 	} }</code></pre> <blockquote> <p><strong>解决方法：</strong></p> <p>1、将函数写在constructor 内部，对事件处理函数bind 绑定this(官方推荐)</p> <p>2、 每次事件绑定都对事件处理函数做bind 绑定</p> <p>3、定义事件处理函数时使用箭头函数</p> <pre><code class="language-javascript">&lt;button onClick={e=&gt;this.changeData.call(this)}&gt;点击改变&lt;/button&gt;</code></pre> <p>当事件处理函数需要传参时：</p> <pre><code class="language-javascript">&lt;button onClick={this.changeData.bind(this,id)}&gt;点击改变&lt;/button&gt;  //将changeData处理为有this &lt;h2&gt;{e=&gt;this.changeData.call(id,event)}&lt;/h2&gt; //又想传参又要处理this，就用call</code></pre> </blockquote> <pre><code class="language-javascript">import React, { Component } from 'react' export default class App extends Component {   constructor() {     super()     this.fn = () =&gt; {       console.log(1111, this.state)     }     this.fn3 = function () {       console.log(333, this.state)     }.bind(this)     // this.state={}   }   fn2() {     console.log(2222, this.state)   }   fn4 = function () {     console.log(44444, this)   }   fn5 = () =&gt; {     console.log(555, this)   }   fn6(arg) {     console.log(arg)   }   fn7(id) {     console.log(id)   }   state = { msg: "hello", arr: [{ id: 123, title: "a" }, { id: 124, title: "bb" }] }   render() {     return (       &lt;div&gt;         &lt;button onClick={this.fn}&gt;btn&lt;/button&gt;         &lt;button onClick={this.fn2.bind(this)}&gt;btn2&lt;/button&gt;         &lt;button onClick={this.fn3}&gt;btn3&lt;/button&gt;         &lt;button onClick={this.fn4.bind(this)}&gt;btn4&lt;/button&gt;         {/* &lt;button onClick={(e)=&gt;{this.fn4(this,e)}}&gt;btn4&lt;/button&gt; */}         &lt;p&gt;{this.state.msg}&lt;/p&gt;         &lt;button onClick={this.fn5}&gt;btn5&lt;/button&gt;         &lt;button onClick={(e) =&gt; { this.fn6(100) }}&gt;btn6&lt;/button&gt;         {           this.state.arr.map(el =&gt; (&lt;div key={el.id}&gt;             &lt;p&gt;{el.title}&lt;/p&gt;             &lt;button onClick={(e) =&gt; { this.fn7(el.id) }}&gt;btn&lt;/button&gt;           &lt;/div&gt;))         }       &lt;/div&gt;     )   } } </code></pre> <h1 id="%E4%BA%8C%E3%80%81React%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">二、React组件生命周期</h1> <p><span style="color:#956fe7;"><strong>render函数 在页面初次加载的时候，会运行；数据每改变一次，页面刷新的时候也会运行。</strong></span></p> <p><span style="color:#956fe7;"><strong>构造函数只会调用一次，从创建到销毁都只调用一次。</strong></span></p> <h2 id="%C2%A01%E3%80%81%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">&nbsp;1、组件的生命周期</h2> <p><span style="color:#956fe7;">- Mounting：已插入真实 DOM</span></p> <p><span style="color:#956fe7;">- Updating：正在被重新渲染</span></p> <p><span style="color:#956fe7;">- Unmounting：已移出真实 DOM</span></p> <p><img fetchpriority="high" decoding="async" alt="" height="900" src="http://img.555519.xyz/uploads/20221230/932662c2c283837200f5d307c945bab0.jpg"></p> <ul> <li> <p><span style="color:#956fe7;"><strong>组件创建阶段（</strong>初始加载<strong>）：</strong>一辈子只执行一次 构造函数（有争议，因为构造函数不算生命周期函数）、componentWillMount: render： componentDidMount：</span></p> </li> <li> <p><span style="color:#956fe7;"><strong>组件运行阶段：</strong>按需，根据props 属性或state 状态的改变，有选择性的执行0 到多次 componentWillReceiveProps: shouldComponentUpdate: componentWillUpdate: render： componentDidUpdate：</span></p> </li> <li> <p><span style="color:#956fe7;"><strong>组件销毁阶段：</strong>一辈子只执行一次</span></p> </li> <li> <p><span style="color:#956fe7;">因为没有了创建前后，想做预加载，就在构造函数或者componentWillMount中做</span></p> </li> </ul> <h2 id="%C2%A02%E3%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%E8%AF%A6%E8%A7%A3">&nbsp;2、生命周期钩子详解</h2> <blockquote> <p>定义：在特定的阶段，你刚刚自动执行的函数（方法）</p> <h3 id="-%20**componentWillMount**%20%EF%BC%9A">- **componentWillMount** ：</h3> <p>在渲染前调用,在客户端也在服务端。</p> <h3 id="-%20**componentDidMount**%20%3A"> <br /> - **componentDidMount** :</h3> <p>在**第一次渲染后**调用，只在客户端。之后组件已经生成了对应的DOM结构，可以通过this.getDOMNode()来进行访问。 如果你想和其他JavaScript框架一起使用，可以在这个方法中调用setTimeout, setInterval或者发送AJAX请求等操作(防止异部操作阻塞UI)。</p> <h3 id="-%20**componentWillReceiveProps**%20%3A"> <br /> - **componentWillReceiveProps** :</h3> <p>在组件接收到一个新的 prop (更新后)时被调用。这个方法在初始化render时不会被调用。</p> <h3 id="-%20**shouldComponentUpdate**%20%3A"> <br /> - **shouldComponentUpdate** :</h3> <p>自己判断是否需要刷新</p> <p>返回一个布尔值。在组件接收到新的props或者state时被调用。在初始化时或者使用forceUpdate时不被调用。 可以在你确认不需要更新组件时使用。</p> <h3 id="-%20**componentWillUpdate**%3A"> <br /> - **componentWillUpdate**:</h3> <p>准备更新</p> <p>在组件接收到新的props或者state但还没有render时被调用。在初始化时不会被调用。</p> <h3></h3> <h3 id="-%20**componentDidUpdate**%20%3A">render函数 在这中间执行</h3> <h3> <br /> - **componentDidUpdate** :</h3> <p>已经更新，数据已经改完了</p> <p>在组件完成更新后立即调用。在初始化时不会被调用。</p> <h3 id="-%20**componentWillUnmount**%3A"> <br /> - **componentWillUnmount**:</h3> <p>即将销毁</p> <p>在组件从 DOM 中移除的时候立刻被调用。</p> </blockquote> <pre><code class="language-javascript">class MyApp extends React.Component { 	constructor(props) { 		super(props); 		this.state = { 			date: new Date() 		}; 	} 	//通过componentDidMount 方法设置一个定时器，每隔1秒重新设置时间，并重新渲染： 	componentDidMount() { 		var oThis=this; 		clearInterval(this.timer);  		this.timer=setInterval(function() { 			oThis.setState({ 				date: new Date() 			}) 		}, 1000) 	}      	render(){ 		return ( 			&lt;h2&gt;{this.state.date.toLocaleTimeString()}&lt;/h2&gt; 		); 	} }</code></pre> <p>父组件的状态传递到子组件的属性中</p> <pre><code class="language-javascript">class Content extends React.Component {     //在渲染前调用,在客户端也在服务端   	componentWillMount() {       	console.log('Component WILL MOUNT!')   	}     //在第一次渲染后调用，只在客户端   	componentDidMount() {        console.log('Component DID MOUNT!')   	}     //在组件接收到一个新的 prop (更新后)时被调用  	componentWillReceiveProps(newProps) {         console.log('Component WILL RECEIVE PROPS!')   	}     //在组件接收到新的props或者state时被调用   	shouldComponentUpdate(newProps, newState) {         return true;   	}     //在组件接收到新的props或者state但还没有render时被调用   	componentWillUpdate(nextProps, nextState) {         console.log('Component WILL UPDATE!');   	}     //在组件完成更新后立即调用   	componentDidUpdate(prevProps, prevState) {         console.log('Component DID UPDATE!')   	}     //在组件从 DOM 中移除的时候立刻被调用   	componentWillUnmount() {          console.log('Component WILL UNMOUNT!')  	}      	render() {   		return (   			&lt;div&gt;   				&lt;h3&gt;{this.props.myNumber}&lt;/h3&gt;   			&lt;/div&gt;   		);   	} }  class MyApp extends React.Component { 	constructor(props) { 		super(props);         //声明状态 		this.state = { 			data: 0,             isRender: true 		}; 		 		this.setNewNumber = this.setNewNumber.bind(this);         this.deleteDOM = this.deleteDOM.bind(this); 	} 	//改变状态值并传递到子组件 	setNewNumber() { 		this.setState({data: this.state.data + 1}); 	}     //删除子组件     deleteDOM() {         this.setState({isRender: false})     } 	 	render() { 		return ( 			&lt;div&gt; 				&lt;button onClick={this.setNewNumber}&gt;点我改变状态&lt;/button&gt;                 &lt;button onClick={this.deleteDOM}&gt;点我删除子组件&lt;/button&gt;                 { this.state.isRender ？ &lt;Content myNumber={this.state.data} /&gt; : null } 			&lt;/div&gt; 		); 	} }  ReactDOM.render( 	&lt;div&gt; 		&lt;MyApp /&gt; 	&lt;/div&gt;, 	document.getElementById('root') );</code></pre> <pre><code class="language-javascript">import React, { Component } from 'react' export default class Box extends Component {   constructor() {     super()     this.state = {       count: 2,       token: "abcdqwe"     }     this.increment1 = function () {       this.setState({ count: this.state.count + 1 })     }     this.changetoken = function () {       this.setState({ token: "abcdqwe2" })     }     console.log("constructor")   }   render() {     console.log("render--box")     return (       &lt;div&gt;         &lt;p&gt;{this.state.count}&lt;/p&gt;         &lt;button onClick={this.increment1.bind(this)}&gt;count++&lt;/button&gt;         &lt;button onClick={this.changetoken.bind(this)}&gt;change_token&lt;/button&gt;       &lt;/div&gt;     )   }   componentWillMount() {     console.log("componentWillMount")   }   componentWillReceiveProps() {     console.log("componentWillReceiveProps")   }   componentDidMount() {     console.log("componentDidMount")   }   componentWillUpdate() {     console.log("componentWillUpdate")   }   shouldComponentUpdate() {     console.log("shouldComponentUpdate", arguments)     //只有传入的有count而是是新值 才更新     if (arguments[1].count &amp;&amp; arguments[1].count != this.state.count) { return true }     else { return false }   }   componentDidUpdate() {     console.log("componentDidUpdate")   }   componentWillUnmount() {     console.log("componentWillUnmount")   } } </code></pre> <h2 id="%C2%A03%E3%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82">&nbsp;3、生命周期钩子——网络请求</h2> <p>componentDidMount</p> <pre><code class="language-javascript">import React, { Component } from 'react' export default class Box2 extends Component {     state={         arr:[]     }   render() {     return (       &lt;div&gt;         &lt;h1&gt;box2&lt;/h1&gt;         {             this.state.arr.map(el=&gt;&lt;div&gt;{el.title}----{el.age}&lt;/div&gt;)         }       &lt;/div&gt;     )   }   componentDidMount(){     fetch("http://192.168.6.78:7001/test").then(res=&gt;res.json())     .then(data=&gt;{         console.log(data)         this.state.arr=data         this.setState(this.state)     })   } } </code></pre> </p></div> 			
                    <div class="col-md-12 mt-5">
                                                <p>上一个：<a href="/html/category/article-621.htm">Spark原理篇之Spark Streaming转化操作和输出操作</a></p>
                                                <p>下一个：<a href="/html/category/article-623.htm">SpringCloud 服务调用监控 Hystrix Dashboard、Turbine</a></p>
                                            </div>

                                    </div>
                <div class="col-md-3">
                	<div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title">热门文章</h3>
    </div>
    <div class="panel-body">
        <ul class="p-0 x-0" style="list-style: none;margin: 0;padding: 0;">
                        <li class="py-2"><a href="/html/category/article-736.htm" title="Elasticsearch 三种分页方式">Elasticsearch 三种分页方式</a></li>
                        <li class="py-2"><a href="/html/category/article-743.htm" title="EditText 不显示光标  光标消失">EditText 不显示光标  光标消失</a></li>
                        <li class="py-2"><a href="/html/category/article-730.htm" title="基于SqlSugar的数据库访问处理的封装，支持.net FrameWork和.net core的项目调用 &#8211; 伍华聪 _在线工具">基于SqlSugar的数据库访问处理的封装，支持.net FrameWork和.net core的项目调用 &#8211; 伍华聪 _在线工具</a></li>
                        <li class="py-2"><a href="/html/category/article-735.htm" title="机器学习笔记：Python底层实现KNN">机器学习笔记：Python底层实现KNN</a></li>
                        <li class="py-2"><a href="/html/category/article-781.htm" title="一文搞定CompletableFuture并行处理，成倍缩短查询时间。">一文搞定CompletableFuture并行处理，成倍缩短查询时间。</a></li>
                        <li class="py-2"><a href="/html/category/article-788.htm" title="深入浅出Vue3 Composition API">深入浅出Vue3 Composition API</a></li>
                        <li class="py-2"><a href="/html/category/article-772.htm" title="如何在代码层面提高CPU分支预测效率">如何在代码层面提高CPU分支预测效率</a></li>
                        <li class="py-2"><a href="/html/category/article-760.htm" title="win11系统怎么隐藏菜单">win11系统怎么隐藏菜单</a></li>
                        <li class="py-2"><a href="/html/category/article-767.htm" title="超详细，Python 多线程总结的太到位了">超详细，Python 多线程总结的太到位了</a></li>
                        <li class="py-2"><a href="/html/category/article-748.htm" title="Halo 开源项目学习实体类与数据表">Halo 开源项目学习实体类与数据表</a></li>
                    </ul>
    </div>
</div>

<div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title">归纳</h3>
    </div>
    <div class="panel-body">
        <ul class="p-0 x-0" style="list-style: none;margin: 0;padding: 0;">
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">22</span> <a href="/html/date/2024-06/" title="2024-06 归档">2024-06</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">62</span> <a href="/html/date/2024-05/" title="2024-05 归档">2024-05</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">60</span> <a href="/html/date/2024-04/" title="2024-04 归档">2024-04</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">62</span> <a href="/html/date/2024-03/" title="2024-03 归档">2024-03</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">54</span> <a href="/html/date/2024-02/" title="2024-02 归档">2024-02</a></h4>
            </li>
                    </ul>
    </div>
</div>

                </div>
            </div>
        </div>
    </section>
        <footer class="ftco-footer ftco-section">
        <div class="container">
            <div class="row">
                <div class="col-md-12 text-center">
                    <p>
                        FinlandAddress 版权所有
                        <br />
                        Powered by WordPress
                    </p>
                </div>
            </div>
        </div>
    </footer>
    <!-- loader -->
    <div id="ftco-loader" class="show fullscreen"><svg class="circular" width="48px" height="48px">
            <circle class="path-bg" cx="24" cy="24" r="22" fill="none" stroke-width="4" stroke="#eeeeee" />
            <circle class="path" cx="24" cy="24" r="22" fill="none" stroke-width="4" stroke-miterlimit="10" stroke="#F96D00" /></svg></div>
    <script src="/assets/addons/xcblog/js/frontend/finlandaddress/jquery.min.js"></script>
    <script src="/assets/addons/xcblog/js/frontend/finlandaddress/jquery-migrate-3.0.1.min.js"></script>
    <script src="/assets/addons/xcblog/js/frontend/finlandaddress/popper.min.js"></script>
    <script src="/assets/addons/xcblog/js/frontend/finlandaddress/bootstrap.min.js"></script>
    <script src="/assets/addons/xcblog/js/frontend/finlandaddress/jquery.easing.1.3.js"></script>
    <script src="/assets/addons/xcblog/js/frontend/finlandaddress/jquery.waypoints.min.js"></script>
    <script src="/assets/addons/xcblog/js/frontend/finlandaddress/jquery.stellar.min.js"></script>
    <script src="/assets/addons/xcblog/js/frontend/finlandaddress/owl.carousel.min.js"></script>
    <script src="/assets/addons/xcblog/js/frontend/finlandaddress/jquery.magnific-popup.min.js"></script>
    <script src="/assets/addons/xcblog/js/frontend/finlandaddress/jquery.animateNumber.min.js"></script>
    <script src="/assets/addons/xcblog/js/frontend/finlandaddress/scrollax.min.js"></script>
    <script src="/assets/addons/xcblog/js/frontend/finlandaddress/main.js"></script>
    <script>
    $(function() {
        $('.js_to').click(function(){
            var url = $(this).data('url');
            var code = $(this).data('code');
            url += code;

            window.open(url);
        })
    });
    </script>
</body>

</html>