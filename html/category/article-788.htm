<!DOCTYPE html>
<html lang="zh-CN">

<head>
        <link rel="canonical" href="https://finlandaddress.github.io/html/category/article-788.htm" />
    <title>深入浅出Vue3 Composition API - FinlandAddress</title>
        <meta charset="utf-8">
    <link rel="icon" href="/assets/addons/xcblog/img/finlandaddress/favicon.ico" type="image/x-icon"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600;700&display=swap" rel="stylesheet" />
    <link href="https://fonts.googleapis.com/css2?family=Raleway:wght@400;500;600;700;800;900&display=swap" rel="stylesheet" />
    <link href="/assets/addons/xcblog/css/finlandaddress/font-awesome.min.css" rel="stylesheet" />
    <link href="/assets/addons/xcblog/css/finlandaddress/animate.css" rel="stylesheet" />
    <link href="/assets/addons/xcblog/css/finlandaddress/owl.carousel.min.css" rel="stylesheet" />
    <link href="/assets/addons/xcblog/css/finlandaddress/owl.theme.default.min.css" rel="stylesheet" />
    <link href="/assets/addons/xcblog/css/finlandaddress/magnific-popup.css" rel="stylesheet" />
    <link href="/assets/addons/xcblog/css/finlandaddress/flaticon.css" rel="stylesheet" />
    <link href="/assets/addons/xcblog/css/finlandaddress/style.css" rel="stylesheet" />
    <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?a045e5bb3ae69629060e7ce2a4b98902";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3332997411212854"
     crossorigin="anonymous"></script>
</head>

<body>
        <nav class="navbar navbar-expand-lg navbar-dark ftco_navbar ftco-navbar-light site-navbar-target" id="ftco-navbar">
        <div class="container">
                        <a class="navbar-brand" href="/">Finland Address<span></span></a>
            
            <button class="navbar-toggler js-fh5co-nav-toggle fh5co-nav-toggle" type="button" data-toggle="collapse" data-target="#ftco-nav" aria-controls="ftco-nav" aria-expanded="false" aria-label="Toggle navigation">
                <span class="oi oi-menu"></span> MENU
            </button>
            <div class="collapse navbar-collapse" id="ftco-nav">
                <ul class="navbar-nav nav ml-auto">
                	                    <li class="nav-item"><a href="/" class="nav-link"><span>首页</span></a></li>
                                        <li class="nav-item"><a href="/html/category/" class="nav-link"><span>文章分类</span></a></li>
                                        <li class="nav-item"><a href="#" class="nav-link"><span>关于</span></a></li>
                    <li class="nav-item"><a href="#" class="nav-link"><span>联系</span></a></li>
                </ul>
            </div>
        </div>
    </nav>
    <section class="hero-wrap" style="height:350px;overflow: hidden;">
        <div class="overlay"></div>
        <div class="container-fluid px-0">
            <div class="row d-md-flex no-gutters slider-text align-items-center js-fullheight justify-content-end">
                <img class="one-third js-fullheight align-self-end order-md-last img-fluid" src="/assets/addons/xcblog/img/finlandaddress/undraw_book_lover_mkck.svg" alt="" style="opacity: 0.5;">
                <div class="one-forth d-flex align-items-center ftco-animate js-fullheight">
                    <div class="text" style="top: 30%;min-width: 70%;">
                        <h1>深入浅出Vue3 Composition API</h1>
                        <p>
                            <a href="/">首页</a> / <a href="/html/category/">文章分类</a> / <span>正文</span>
                        </p>
                    </div>
                </div>
            </div>
        </div>
    </section>
    <section class="ftco-about img ftco-section" id="about-section">
        <div class="container">
            <div class="row">
                <div class="col-md-9">
                	  				  				  				<div id="content_views" class="markdown_views prism-atom-one-light"> <p><img decoding="async" src="http://img.555519.xyz/uploads3/20220604/4c0c365f619dbcd71bb96fe04900d6b8.jpg" alt="深入浅出Vue3 Composition API"></p> <h1>vue3改动的地方</h1> <ul> <li>使用Typescript</li> <li>放弃class采用function-based API（vue2是new Vue，vue3是createApp）</li> <li>option API => Composition API</li> <li>重构complier</li> <li>重构virtual DOM</li> <li>新的响应式机制</li> </ul> <h1>Vue2中的跨组件重用代码方案</h1> <ol> <li> <p>Mixin - 混入</p> <p>代码混入其实就是设计模式中的混合模式，缺点也非常明显。可以理解为多重继承，简单的说就是一个人如何有两个父亲</p> <p>缺点是：无法避免属性名冲突 - 比如长鼻子、眼睛、嘴巴随谁；继承关系不清晰；不清楚这些mixin是什么以及如何交互</p> </li> <li> <p>Mixin Factory - 混入工厂</p> <p>特点：通过function返回mixin的定制版本，引用时通过namespace重新命名。代码重用方便；继承关系清洗；命名空间需要强大的约定和规则来做正确的事情；我们仍然需要查看每个mixin内部，并查看它暴露了哪些属性。</p> </li> <li> <p>ScopeSlots - 作用域插槽</p> <p>可读性不高</p> <p>配置复杂，需要在模版中进行配置</p> <p>性能低，每个插槽相当于一个实例</p> </li> </ol> <p>mixins混入</p> <h1>为什么要选择CompositionAPI</h1> <h2>vue2的局限性</h2> <ul> <li>组件逻辑膨胀导致的可读性变差</li> <li>无法跨组件重用代码</li> <li>vue2对TS的支持有限</li> </ul> <h2>CompositionAPI解决了什么问题</h2> <p>面对vue2的局限性最佳的解决方法是将逻辑聚合就可以很好的代码可读性。</p> <blockquote> <p>CompositionAPI是一个完全可选的语法与原来的OptionAPI并没有冲突之处。它可以让我们将相同功能的代码组织在一起，而不需要散落到optionsAPI的各个角落。</p> </blockquote> <h2>CompositionAPI优点</h2> <ul> <li>composition API是根据逻辑相关性组织代码的，提高可读性和维护性</li> <li>代码量少，更好的重用逻辑代码</li> <li>没有引入新的语法，只是单纯函数</li> <li>异常灵活</li> <li>工具语法提示友好，因为是单纯函数所以很容易实现语法提示、自动补偿</li> <li>更好的Typescript支持</li> <li>在复杂功能组件中可以实现根据特性组织代码，代码内聚性强</li> <li>组件间代码复用</li> </ul> <h1>了解CompositionAPI</h1> <p>参考掘金上一篇动画看下：</p> <h2>回顾Option Api</h2> <p>在传统的OptionsAPI中我们需要将逻辑分散到以下六个部分：</p> <ul> <li><code>components</code></li> <li><code>props</code></li> <li><code>data</code></li> <li><code>computed</code></li> <li><code>methods</code></li> <li><code>lifecycle methods</code></li> </ul> <p><img decoding="async" src="http://img.555519.xyz/uploads3/20220604/076f260438e8abd1b519e1b0c15c511e.jpg" alt="深入浅出Vue3 Composition API"></p> <blockquote> <p>随着业务复杂度越来越高，代码量会不断的加大；由于相关业务的代码需要遵循option的配置写到特定的区域，导致后续维护非常的复杂，代码可复用性也不高</p> </blockquote> <p><img decoding="async" src="http://img.555519.xyz/uploads3/20220604/e640f58bd8e82f11c2524bc9ed4fe342.jpg" alt="深入浅出Vue3 Composition API"></p> <h2>CompositionAPI</h2> <p>可以更加优雅的组织代码，函数。让相关功能的代码更加有序的组织在一起.</p> <p><img decoding="async" src="http://img.555519.xyz/uploads3/20220604/316837656c966a9fa3eefa1e7502382f.jpg" alt="深入浅出Vue3 Composition API"></p> <p><img decoding="async" src="http://img.555519.xyz/uploads3/20220604/d777e814397cf458c3d0e355b72c05d5.jpg" alt="深入浅出Vue3 Composition API"></p> <h2>总结</h2> <table> <thead> <tr> <th>Options API</th> <th>Composition-API</th> </tr> </thead> <tbody> <tr> <td>不利于复用</td> <td>方便代码复用，关注点分离</td> </tr> <tr> <td>潜在命名冲突，数据源来源不清晰</td> <td>数据来源清晰</td> </tr> <tr> <td>上下文丢失</td> <td>提供更好的上下文</td> </tr> <tr> <td>有限类型支持</td> <td>更好的<strong>TypeScript</strong>支持</td> </tr> <tr> <td>按API类型支持</td> <td>按功能/逻辑组织，方便代码复用</td> </tr> <tr> <td>响应式数据必须在组件的<code>data</code>中定义</td> <td>可独立vue组件使用</td> </tr> </tbody> </table> <h1>简单看一段vue3代码</h1> <pre><code>// index.vue <template>   <h1>Vue2的data选项已经被ref、reactive这样的API给替换了</h1>   <div>num:{<!-- -->{num}}</div>   <div>refNum:{<!-- -->{refNum}}</div>   <div>state对象:名字:{<!-- -->{state.name}},年龄:{<!-- -->{state.age}}</div>   <!-- 这里不再需要state包裹了，属性已经被展开return出来了   <div>state对象:名字:{<!-- -->{name}},年龄:{<!-- -->{age}}</div> -->   <h1>computed写法有变化了</h1>   <div>{<!-- -->{newCount}}</div>   <div>{<!-- -->{list}}</div>   <h1>watch与watchEffect监听</h1>   <div>newCountVal:{<!-- -->{newCountVal}}</div>   <div>person对象:名字:{<!-- -->{person.name}},年龄:{<!-- -->{person.age}}</div> </template>  // script import { defineComponent, reactive, ref, toRefs, computed, watch, watchEffect } from "vue" import { useStore } from 'vuex' export default defineComponent({   setup() {     const num = 1  //不具备响应式     const refNum = ref(2)     const state = reactive({       name: '小黄',       age: 18     })     console.log(state, 'state---'); // Proxy对象     console.log(state.name) // 小黄     console.log(state.age) // 18     // 对数据更改     setTimeout(() => {       state.age = 20       console.log(state.age) // => 20     }, 1000)      //  ref声明的数据可以直接使用.value这种形式更新数据，视图不需要.value，其实是vue内部做了操作     const count = ref(1)     console.log(count, 'count--');     console.log(count.value) // 1     count.value++     console.log(count.value) // 2      const str = ref('小黄')     console.log(str.value) //小黄       // computed     const cnt = ref(3)     console.log(cnt.value) // 3     const newCount = computed(() => cnt.value + 1)     console.log(newCount.value) // 4     // 计算属性中获取Vuex的数据的话，可以使用Vuex提供的 useStore 模块获取到store的实例     const store = useStore()     const list = computed(() => store.state.list)       watch     const newCountVal = ref(10)     setTimeout(() => {       newCountVal.value = 20     }, 2000)     watch(newCountVal, (newValue, oldValue) => {       console.log(oldValue, newValue) // watch监听到count变化     })      const person = reactive({       name: '前端发现',       age: 18     })     setTimeout(() => {       person.name = '我是reactive定义的name属性更改后的数据';       person.age = 22     }, 2000)     // 单个属性监听变化     watch(() => person.name, (newValue, oldValue) => {       console.log(oldValue)       console.log(newValue)     })     // 多个属性监听变化     // watch([count, () => person.name, () => person.age], ([newCount, newName, newAge], [oldCount, oldName, oldAge     // ]) => {     //   console.log(oldCount, oldName, oldAge)     //   console.log(newCount, newName, newAge)     // })       watchEffect     watchEffect(() => console.log(newCountVal.value, '我是watchEffect执行结果'))      // 监听多个变化     // watchEffect(() => {     //   console.log(newCountVal.value)     //   console.log(person.name)     // })     setTimeout(() => {       count.value = 20 // 立即执行watchEffect方法     }, 1000)      return {       num,       refNum,       state,       // ...toRefs(state),       newCount,       list,       newCountVal,       person     }   } })</code></pre> <h1>CompositionAPI</h1> <h2>setup</h2> <h3>是什么</h3> <blockquote> <p>一个组件选项，在创建组件<strong>之前</strong>执行，并作为Composition API的入口。setup中是没有<code>this</code>上下文的。</p> <p>可以简单理解为组件的一个配置项，值是一个函数。组件中所使用到的数据，方法，计算属性等都要配置在<code>setup</code>里。</p> </blockquote> <h3>参数</h3> <p>使用<code>setup</code>时，它接受两个参数：</p> <ul> <li>props：组件传入的属性，是一个响应式对象，不能使用<code>ES6</code>解构，和Vue2.x中的props一致</li> <li>context：上下文对象</li> </ul> <pre><code>setup (props,context) { 	console.log(props, 'props');   console.log(context, 'context');   // context.attrs; //Attributes   // context.slots; //slots   // context.emit; //tirgger event   // context.listeners; // events   // context.root; // root component instance   // context.parent; // parent component isntance   // context.refs; // all refs 	const {attrs,slots,emit} = context // 分别对应Vue2.x中的$attr属性、slot插槽和$emit发射事件。并且这几个属性都是自动同步最新的值，所以我们每次使用拿到的都是最新值 }</code></pre> <p><img decoding="async" src="http://img.555519.xyz/uploads3/20220604/79dac6c1b72e6a53543a1db54860e1e0.jpg" alt="深入浅出Vue3 Composition API"></p> <h4>context属性说明</h4> <ul> <li><code>attrs</code>：组件外部传递过来的，但是没有在<code>props</code>配置中声明的属性，内部组件实例上对应项的代理</li> <li><code>slots</code>：收到的插槽内容。内部组件实例上对应项的代理，默认名是<code>default</code></li> <li><code>emit</code>：分发自定义事件的函数</li> <li><code>root</code>：根组件的实例</li> </ul> <h3>执行时机</h3> <p>在beforeCreate之前执行</p> <pre><code>export default defineComponent({   beforeCreate() {     console.log("----beforeCreate----");   },   created() {     console.log("----created----");   },   setup() {     console.log("----setup----");   }, }); // 输出结果 ----setup---- ----beforeCreate---- ----created----</code></pre> <h3>注意</h3> <p>由于<code>setup()</code>是在<code>beforeCreate</code>,<code>created</code>之前执行，因此：</p> <ul> <li>不能在<code>setup()</code>函数中使用<code>this</code>，因为此时组件并没有完全实例化</li> <li>不能在<code>setup()</code>函数中使用<code>beforeCreate</code>与<code>created</code>两个组合生命周期</li> </ul> <h2>生命周期钩子</h2> <p>可以使用直接导入的<code>onX</code> 函数注册生命周期钩子，这些函数接受一个回调函数，当钩子被组件调用时将会被执行：</p> <pre><code>import { onMounted, onUpdated, onUnmounted } from 'vue'  setup() {   onMounted(() => {   	console.log('mounted!')   })   onUpdated(() => {    console.log('updated!')   })   onUnmounted(() => {    console.log('unmounted!')   }) }</code></pre> <p>这些生命周期钩子注册函数只能在<code>setup</code> 期间同步使用，因为它们依赖于内部全局状态来定位当前活动实例 (此时正在调用其<code>setup()</code>的组件实例)。在没有当前活动实例的情况下调用它们将导致错误。</p> <p>组件实例上下文也是在生命周期钩子的同步执行期间设置的，因此在生命周期钩子内同步创建的侦听器和计算属性也会在组件卸载时自动删除。</p> <p><strong>Vue2生命周期选项和Vue3之间的映射</strong></p> <table> <thead> <tr> <th><strong>选项式 API</strong></th> <th><strong>Hook inside</strong><code>setup</code></th> </tr> </thead> <tbody> <tr> <td>beforeCreate</td> <td>Not needed*</td> </tr> <tr> <td>created</td> <td>Not needed*</td> </tr> <tr> <td>beforeMount</td> <td>onBeforeMount</td> </tr> <tr> <td>mounted</td> <td>onMounted</td> </tr> <tr> <td>beforeUpdate</td> <td>onBeforeUpdate</td> </tr> <tr> <td>updated</td> <td>onUpdated</td> </tr> <tr> <td>beforeUnmount</td> <td>onBeforeUnmount</td> </tr> <tr> <td>unmounted</td> <td>onUnmounted</td> </tr> <tr> <td>errorCaptured</td> <td>onErrorCaptured</td> </tr> <tr> <td>renderTracked</td> <td>onRenderTracked</td> </tr> <tr> <td>renderTriggered</td> <td>onRenderTriggered</td> </tr> </tbody> </table> <blockquote> <p>因为<code>setup</code>是围绕<code>beforeCreate</code>和<code>created</code>生命周期钩子运行的，所以不需要显式地定义它们。换句话说，在这些钩子中编写的任何代码都应该直接在<code>setup</code>函数中编写。</p> </blockquote> <h2>Provide / Inject</h2> <p>提供依赖注入，实现祖孙组件间通信，类似于vue2中<code>provide</code>与<code>inject</code>, vue3提供了对应的<code>provide</code>与<code>inject</code> API，两者都只能在当前活动组件实例的<code>setup()</code> 中调用。父组件有一个<code>provide</code>选项来提供数据，子组件有一个<code>inject</code>选项来开始使用这些数据。下图来自官网：</p> <p><img decoding="async" src="http://img.555519.xyz/uploads3/20220604/0f25f7aa239ea06ae884aa5bfdc4909a.jpg" alt="深入浅出Vue3 Composition API"></p> <h3><strong>provide用法</strong></h3> <p>provide接受两个参数，第一个参数是provide唯一名称，最好用Symbol，避免重复。第二个参数是需要暴露的数据。</p> <pre><code>provide(ThemeSymbol, 'dark')</code></pre> <h3><strong>inject 用法</strong></h3> <p>inject接收两个参数，第一个参数是provide名称，第二个参数是默认数据。如果provider没有暴露自己的数据，那么使用inject默认数据</p> <pre><code>inject(ThemeSymbol, 'light' /* optional default value */)</code></pre> <h3>例子</h3> <pre><code>// 提供者： const ThemeSymbol = Symbol() setup() { 	// ref注入响应式对象 	const themeRef = ref('dark') 	provide(ThemeSymbol, themeRef) }  // 使用者 setup() { 	const theme = inject(ThemeSymbol, ref('light')) }</code></pre> <h2>getCurrentInstance</h2> <p>获取当前执行<code>setup</code>函数的组件实例。 需要注意的是，<code>getCurrentInstance</code>只能在<code>setup</code>中执行或者在生命周期钩子中执行。</p> <pre><code>import {getCurrentInstance} from 'vue';  setup(props, ctx){   onMounted(()=>{    const vm =  getCurrentInstance();    console.log(vm);   }); }</code></pre> <p><img decoding="async" src="http://img.555519.xyz/uploads3/20220604/1b16ccf08aa0051c9fed63cdf811c726.jpg" alt="深入浅出Vue3 Composition API"></p> <h2>Composition API带来的变化</h2> <h3>响应式基础API</h3> <h4>reactive</h4> <p><code>reactive</code>函数内部机遇<code>ES6</code>的<code>Proxy</code>实现</p> <p>reactive接收一个普通的对象，返回出一个响应式对象。 在Vue2.x的版本中，我们只需要在data中定义一个数据就能将它变为响应式数据，在Vue3.0中，需要用reactive函数或者ref来创建响应式数据。<code>reactive</code>的响应式数据是深层次的。</p> <h5>例子</h5> <pre><code><template>   <div>person对象:名字:{<!-- -->{person.name}},年龄:{<!-- -->{person.age}}</div> </template>  <script> import { defineComponent, reactive, watch } from "vue" export default defineComponent({   setup() {     const person = reactive({       name: '前端发现',       age: 18     })     setTimeout(() => {       person.name = '我是reactive定义的name属性更改后的数据'     }, 2000)      watch(() => person.name, (newValue, oldValue) => {       console.log(oldValue)       console.log(newValue)     })     return {       person     }   } }) </script> // 输出结果 before person对象:名字:前端发现,年龄:18 after person对象:名字:我是reactive定义的name属性更改后的数据,年龄:22</code></pre> <h5>注意</h5> <ul> <li> <p>所有setup和组合函数中不能返回reactive的解构，否则会丢失响应式，可以使用<code>toRefs</code>API解决</p> </li> <li> <p>如果将<code>ref</code>与<code>reactive</code>结合使用，可以通过<code>reactvie</code>方法重新定义<code>ref</code>对象，会自动展开<code>ref</code>对象的原始值，类似与自动解包无需再通过<code>.value</code>方式访问其值。当然，这并不会解构原始<code>ref</code> 对象</p> <pre><code>const foo = ref(''); const r = reactive({foo}); r.foo === foo.value; // 但是不能通过字面量的形式将一个ref添加到一个响应式对象中 const foo = ref(''); const r = reactive({}); r.foo = foo; // 报错</code></pre> </li> </ul> <h4><code>readonly</code></h4> <p>获取一个对象 (响应式或纯对象) 或<code>ref</code>并返回原始代理的只读代理。只读代理是深层的：访问的任何嵌套property也是只读的</p> <pre><code>const original = reactive({ count: 0 })  const copy = readonly(original)  watchEffect(() => {   // 适用于响应性追踪   console.log(copy.count) })  // 变更original 会触发侦听器依赖副本 original.count++  // 变更副本将失败并导致警告 copy.count++ // 警告!</code></pre> <h4>toRaw</h4> <p>返回reactive或readonly代理的原始对象。这是一个转义口，可用于临时读取而不会引起代理访问/跟踪开销，也可用于写入而不会触发更改。不建议保留对原始对象的持久引用。请谨慎使用。</p> <pre><code>const foo = {} const reactiveFoo = reactive(foo)  console.log(toRaw(reactiveFoo) === foo) // true</code></pre> <h3>Refs</h3> <h4>ref、toRef和toRefs</h4> <h5>ref</h5> <h6>ref是什么呢</h6> <ul> <li>可以生成<code>值类型</code>（即基本数据类型） 的响应式数据</li> <li>可以用于<strong>模板</strong>和<strong>reactive</strong></li> <li>通过<code>.value</code> 来修改值（注意一定要记得加上<code>.value</code> ）</li> <li>不仅可以用于<strong>响应式</strong>，还可以用于模板的<code>DOM</code> 元素</li> <li>ref背后也是通过reactive实现的</li> </ul> <p>总结下就是ref用来定义一个响应式数据，返回一个包含响应式数据的对象。一般用来定义一个基本数据类型，但是也可以定义引用类型。</p> <blockquote> <p><code>ref</code>如果传入基本数据类型依然是基于<code>Object.defineProperty()</code>的<code>get</code>和<code>set</code>完成的。如果传入的是引用类型，内部是调用了<code>reactive</code>函数，是基于<code>Proxy</code>实现对象的代理。</p> </blockquote> <h6>看个例子</h6> <pre><code>// template <template>   <!-- 模版不需要.value-->   <p>{<!-- -->{ msg }}</p>   <p>{<!-- -->{ person.name }}</p>   <button @click="handleClick">修改</button> </template>  <script> import { ref } from 'vue' export default {   name: 'App',   setup() {     // 基本数据类型     const msg = ref('一条消息')     // 引用类型     const person = ref({ name: '张三', age: 20 })     // 修改数据时使用.value操作     function handleClick() {       msg.value = '新的消息'       person.value.name = '李四'     }     return {       msg,       person,       handleClick     }   } } </script></code></pre> <h6>ref作用</h6> <ul> <li>实现响应式</li> <li>渲染模板中的DOM元素</li> </ul> <pre><code><template>    <p ref="elemRef">今天是周一</p> </template>  <script> import { ref, onMounted } from 'vue' export default {     name: 'RefTemplate',     setup(){         const elemRef = ref(null)         onMounted(() => {           console.log('ref template', elemRef.value.innerHTML, elemRef.value)         })         return{             elemRef         }     } } </script> // 输出结果 ref template 今天是周一 <p>今天是周一</p></code></pre> <p><img decoding="async" src="http://img.555519.xyz/uploads3/20220604/f6d680c8eb501f5884dfb329698a96c0.jpg" alt="深入浅出Vue3 Composition API"></p> <h6>为什么需要用ref</h6> <ul> <li><strong>值类型</strong>（即基本数据类型）无处不在，如果不用<code>ref</code>而直接返回值类型，<strong>会丢失响应式</strong></li> <li>比如在**<code>setup</code>** 、<strong><code>computed</code></strong> 、<strong>合成函数</strong>等各种场景中，都有可能返回<strong>值类型</strong></li> <li><code>Vue</code> 如果不定义<code>ref</code> ，用户将自己制造<code>ref</code> ，这样反而会更加混乱</li> </ul> <h6>为什么ref需要.value属性</h6> <p>我们知道<code>ref</code> 需要通过<code>.value</code>来修改值。看起来好像是挺麻烦的，总是频繁的<code>.value</code>特别琐碎且麻烦。那为什么一定要<code>.value</code> ？我们来看看原因</p> <ul> <li><code>ref</code>是一个<strong>对象</strong>，这个对象不丢失响应式，且这个对象用<code>value</code>来存储值</li> <li>因此，通过<code>.value</code>属性的<code>get</code>和<code>set</code>来实现响应式</li> <li>只有当用于<strong>模板</strong>和<strong>reactive</strong>时，不需要<code>.value</code>来实现响应式，而<strong>其他情况则都需要</strong></li> </ul> <h6>总结</h6> <ul> <li>JS ：需要通过.value操作对象</li> <li>模板: 自动拆箱</li> </ul> <h5>toRef</h5> <h6>toRef是什么？</h6> <blockquote> <p>可以用来为一个reactive对象（源响应式对象上）的属性（property）创建一个ref。这个ref可以被传递并且能够保持响应性</p> </blockquote> <ul> <li><code>toRef</code>针对的是某一个响应式对象<code>reactive</code>封装的属性<code>prop</code></li> <li><code>toRef</code> 如果用于普通对象（非响应式对象），产出的结果不具备响应式</li> </ul> <h6>语法</h6> <p><code>toRef(Object, prop)</code> 的形式来传<strong>对象名</strong>和<strong>具体的属性名</strong>，达到某个属性数据响应式的效果</p> <blockquote> <p>对于一个普通对象来说，如果这个普通对象要实现响应式，就需要用到<code>reactive</code> 。用了<code>reactive</code>之后，它就在响应式对象里面。那么在一个响应式对象里面，如果其中有<strong>一个属性</strong>要拿出来单独做响应式的话，就要用到<code>toRef</code></p> </blockquote> <h6>看个例子</h6> <pre><code><template>   <h1>toRef</h1>   <p>toRef demo - {<!-- -->{ newAgeRef }} - {<!-- -->{ newState.name }} {<!-- -->{ newState.age }}</p> </template>  <script> import { ref, reactive, onMounted, toRef, toRefs } from "vue"; export default {   name: "Ref",   setup(props, context) {      toRef     const newState = reactive({       age: 18,       name: "monday",     });      // toRef 如果用于普通对象（非响应式对象），结果不具备响应式     // const newState = {     //   age: 18,     //   name: 'monday'     // }      //实现某一个属性的数据响应式     const newAgeRef = toRef(newState, "age");     setTimeout(() => {       newState.age = 20;     }, 1500);      setTimeout(() => {       newAgeRef.value = 25; // .value 修改值     }, 3000);       toRefs     const toRefsState = reactive({       age: 18,       name: "monday",     });      return {       newAgeRef,       newState,     };   }, }; </script>  // 输出结果 toRef demo - 18 - monday 18 toRef demo - 20 - monday 20 toRef demo - 25 - monday 25</code></pre> <h5>toRefs</h5> <h6>toRefs是什么？</h6> <blockquote> <p>将响应式对象转换为普通对象，其中结果对象的每个property都是指向原始对象相应 property 的<code>ref</code>，不会丢失响应性</p> </blockquote> <ul> <li>与<code>toRef</code>不一样的是，<code>toRefs</code>是针对整个对象的所有属性，目标在于将响应式对象（<code>reactive</code> 封装）转换为普通对象</li> <li>普通对象里的每一个属性都对应一个<code>ref</code></li> </ul> <pre><code>const state = reactive({   foo: 1,   bar: 2 })  const stateAsRefs = toRefs(state) /* Type of stateAsRefs:  {   foo: Ref<number>,   bar: Ref<number> } */  // ref 和 原始property “链接” state.foo++ console.log(stateAsRefs.foo.value) // 2  stateAsRefs.foo.value++ console.log(state.foo) // 3</code></pre> <p>当从合成函数返回响应式对象时，<code>toRefs</code>非常有用，这样消费组件就可以在不丢失响应性的情况下对返回的对象进行分解/扩散：</p> <pre><code>function useFeatureX() {   const state = reactive({     foo: 1,     bar: 2   })   // 逻辑运行状态   // 返回时转换为ref   return toRefs(state) }  export default {   setup() {     // 可以在不失去响应性的情况下破坏结构     const { foo, bar } = useFeatureX()     return {       foo,       bar     }   } }</code></pre> <h6>看个例子</h6> <pre><code><template>     <p>toRefs demo {<!-- -->{ age }} {<!-- -->{ name }}</p> </template>  <script> import { ref, toRef, toRefs, reactive } from 'vue'  export default {     name: 'ToRefs',     setup() {         const newState = reactive({           age: 18,           name: "monday",         });          const stateAsRefs = toRefs(newState); // 将响应式对象，变成普通对象         setTimeout(() => {           console.log('newState before--', newState.age, newState.name)           newState.age = 20,           newState.name = '周一'           console.log('newState after--', newState.age, newState.name)           console.log(stateAsRefs, 'stateAsRefs---');         }, 1500);          return {         	...stateAsRefs         }     } } </script> // 输出结果 toRefs demo 18 monday toRefs demo 20 周一</code></pre> <h6>总结</h6> <p><code>toRefs</code>在setup或者Composition Function（合成函数）的返回值特别有用。</p> <h6>为什么需要toRef和toRefs</h6> <blockquote> <p>与<code>ref</code>不一样的是，<code>toRef</code>和<code>toRefs</code> 这两个兄弟，它们<strong>不创造响应式</strong>，而是<strong>延续响应式</strong>。创造响应式一般由<code>ref</code>或者<code>reactive</code> 来解决，而<code>toRef</code>和<code>toRefs</code>则是把对象的数据进行分解和扩散，其这个对象针对的是<strong>响应式对象</strong>而<strong>非普通对象</strong>。<strong>总结起来有以下三点</strong>：</p> <ul> <li>在<strong>不丢失响应式</strong>的情况下，把对象数据进行<strong>分解或扩散</strong></li> <li>针对的是<strong>响应式对象</strong>（<code>reactrive</code> 封装的）而<strong>非普通对象</strong></li> <li><strong>不创造</strong>响应式，而是<strong>延续</strong>响应式</li> </ul> </blockquote> <h6>总结</h6> <ul> <li>用<code>ref</code>做<strong>值类型</strong>的响应式</li> <li><code>toRef</code>为源响应式对象上的属性创建一个<code>ref</code>。然后可以将ref传递出去，从而保持对其源属性的响应式连接</li> <li><code>toRefs</code>将响应式对象转换为普通对象，其中结果对象的每个属性都是指向原始对象相应属性的<code>ref</code></li> <li>为了防止误会产生，<code>ref</code>的变量命名尽量都用<code>xxxRef</code> ，这样在使用的时候会更清楚明了</li> <li><strong>合成函数</strong>返回<strong>响应式对象</strong>时，使用<code>toRefs</code></li> <li><code>toRefs</code>方法可以解构为多个<code>Ref</code>对象的引用</li> </ul> <h4>customRef</h4> <h5>定义</h5> <p>创建一个自定义的ref，并对其依赖项跟踪和更新触发进行显式控制。它需要一个工厂函数，该函数接收<code>track</code>和<code>trigger</code>函数作为参数，并应返回一个带有<code>get</code>和<code>set</code>的对象。</p> <h5>例子</h5> <p>使用<code>v-model</code>使用自定义ref实现<code>debounce</code>的示例</p> <pre><code>// 模版 <input v-model="text" />  // script function useDebouncedRef(value, delay = 200) {   let timeout   return customRef((track, trigger) => {     return {       get() {         track()         return value       },       set(newValue) {         clearTimeout(timeout)         timeout = setTimeout(() => {           value = newValue           trigger()         }, delay)       }     }   }) }  export default {   setup() {     return {       text: useDebouncedRef('hello')     }   } }</code></pre> <h3>computed</h3> <p>computed函数与vue2中computed功能一致，它接收一个函数并返回一个value为getter返回值的不可改变的响应式ref对象。</p> <p>不同的是computed被抽成一个API，直接从vue中获取，而Vue2.x中，computed是一个对象，在对象中定义一个computed。</p> <p>有两种编写形式</p> <ul> <li>接受一个<code>getter</code>函数的简写方式，即直接传一个函数,返回你所依赖的值的计算结果，这个值是个包装对象，默认情况下，如果用户试图去修改一个只读包装对象，会触发警告，只能get无法set。</li> <li>接收<code>get</code>和<code>set</code>函数的对象的方式，即传一个对象，对象包含get函数和set函数</li> </ul> <pre><code>// getter简写形式 <template> 	<div>{<!-- -->{newCount}}</div> </template>  // script import { computed } from 'vue' setup{ 	const cnt = ref(3)   console.log(cnt.value) // 3   const newCount = computed(() => cnt.value + 1)   console.log(newCount.value) // 4      return{   	newCount   } }  // get和set函数的对象的方式 setup{ 	const cnt = ref(3)   console.log(cnt.value) // 3   const newCount = computed({   	get() {       return cnt.value + 1     },     set(newVal) {     	//赋值     	cnt.value = newVal - 1       console.log(newVal)     }   })   console.log(newCount.value) // 4      return{   	newCount   } }</code></pre> <p><strong>总结</strong></p> <ul> <li>computed返回值是readonly形式，默认不可更改</li> <li>如果computed用reactive包裹的话，会自动拆装箱，computed里面就不用.value了</li> </ul> <h3>watch和watchEffect</h3> <h4>watch</h4> <p><code>watch</code> API 与选项式 API<code>this.$watch</code> (以及相应的<code>watch</code>选项) 完全等效。<code>watch</code> 需要侦听特定的data源，并在单独的回调函数中副作用。默认情况下，它也是惰性的，即回调是仅在侦听源发生更改时调用。</p> <h5>语法</h5> <pre><code>watch(params，handler(newValue, oldValue), { immediate: true, deep: true })</code></pre> <p>watch传入三个参数：</p> <ol> <li><code>params</code>：一个响应式属性或<code>getter</code>函数</li> <li><code>handler</code>：回调函数</li> <li><code>object</code>：可选配置项</li> </ol> <h5>特点</h5> <ul> <li>具有懒执行的特性，并不会立即执行</li> <li>要明确哪些依赖项的状态改变，触发侦听器的重新执行，支持监听多个依赖</li> <li>能够获得状态变更前后的值</li> <li>可以手动停止监听</li> </ul> <h5>侦听一个单一源</h5> <p>侦听器 data 源可以是返回值的 getter 函数，也可以是<code>ref</code></p> <pre><code>// 侦听一个getter const state = reactive({ count: 0 }) watch(   () => state.count,   (count, prevCount) => {     /* ... */   } )  // 直接侦听一个ref const count = ref(0) watch(count, (count, prevCount) => {   /* ... */ })</code></pre> <p><strong>看个例子</strong></p> <pre><code>// 侦听一个getter setup{ 		const state = reactive({ nickname: "xiaofan", age: 20 });     setTimeout(() => {       state.age++;     }, 1000);       监听reactive定义的数据     // 修改age值时会触发watch的回调     watch(() => state.age,(curAge, preAge) => {       console.log("新值:", curAge, "老值:", preAge);     }); } // 直接侦听一个ref setup{ 		const year = ref(0);     setTimeout(() => {       year.value++;     }, 1000);     watch(year, (newVal, oldVal) => {       console.log("新值:", newVal, "老值:", oldVal);     }); }</code></pre> <h5>侦听多个源</h5> <p>侦听器还可以使用数组同时侦听多个源：</p> <pre><code>watch([fooRef, barRef], ([foo, bar], [prevFoo, prevBar]) => {   /* ... */ })</code></pre> <p><strong>看个例子</strong></p> <pre><code>// 同时监听ref定义的多个响应式数据  // template <el-input type="text" v-model="name" /> <el-input type="text" v-model.number="age" />  // script setup{ 		const name = ref('张三')     const age = ref(20)     // newValue和oldValue分别是一个数组,和监听变量的顺序一一对应     watch([name, age], (newValue, oldValue) => {       console.log(newValue, '+++++++') // [newName, newAge]       console.log(oldValue, '=======') // [oldName, oldAge]     })     return {     	name,     	age     } }  // 同时监听reactive定义的多个响应式数据  // template <div>person.name{<!-- -->{person.name}}</div> <div>person.age{<!-- -->{person.age}}</div> <div>person.job.jobName{<!-- -->{person.job.jobName}}</div>  // script setup{ 		const person = reactive({       name: '张三',       age: 20,       job: {         jobName: '工程师',         area: {           areaName: '上海'         }       }     })     setTimeout(() => {       person.name = '李四'       person.age = 30       person.job.jobName = '设计师'       console.log('--------');     }, 1000)          watch([() => person.name, () => person.age, () => person.job],(newValue, oldValue) => {       console.log(newValue, 'newValue--');       console.log(oldValue, 'oldValue--');     },{ deep: true })	          return{     	person     } }</code></pre> <h5>清除副作用</h5> <p><strong>为什么需要清除副作用？</strong></p> <p>有这样一种场景，在watch中执行异步操作时，在异步操作还没有执行完成，此时第二次watch被触发，这个时候需要清除掉上一次异步操作。</p> <p>watch提供了一个onCleanup的副作用清除函数，该函数接收一个函数，在该函数中进行副作用清除。</p> <p><strong>onCleanup什么时候执行？</strong></p> <ul> <li>watch的callback即将被第二次执行时先执行onCleanup</li> <li>watch被停止时，即组件被卸载之后</li> <li>watch选项（包括lazy、deep、flush）</li> </ul> <pre><code>const getData = (value) => { 	const handler = setTimeout(() => { 		console.log('数据', value) 	}, 5000) 	return handler }  const inputRef = ref('') watch(inputRef, (val, oldVal, onCleanup) => { 	const handler = getData(val) // 异步操作 	// 清除副作用 	onCleanup(() => { 		clearTimeout(handler) 	}) })  return {inputRef}</code></pre> <h5>停止监听</h5> <pre><code>setup{ 	const stopWatch = watch('xxxx'); 	// 执行即可停止监听 	// watch返回一个函数 function(){ stop() } 	stopWatch() 	return {}; }</code></pre> <h4>watchEffect</h4> <p><code>watchEffect</code>函数不用指明监听哪个属性，监听的回调中用到哪个属性，就监听哪个属性。在响应式地跟踪其依赖项时立即运行一个函数，并在更改依赖项时重新运行它。默认初始化时会执行一次。</p> <h5>特点</h5> <ul> <li>会立即执行副作用方法。并且当内部所依赖的响应式值发生改变时也会重新执行</li> <li>不需要指定监听属性，可以自动收集依赖</li> <li>可以通过<code>onInvalidate</code> 取消监听</li> </ul> <pre><code>setup{ 		const person = reactive({       name: '张三',       age: 20,       job: {         jobName: '工程师',         area: {           areaName: '上海'         }       }     })     setTimeout(() => {       person.name = '李四'       person.age = 30       person.job.jobName = '设计师'       console.log('--------');     }, 1000)          watchEffect(() => {       console.log(person.name, 'watchEffect--')       console.log(person.job.jobName, 'watchEffect++')       onInvalidate(() => {         // TODO       })     }) }</code></pre> <h5>注意</h5> <blockquote> <p>需要注意，当副作用函数中执行的函数，若该函数又改变了响应式的数据，可能会造成死循环问题。</p> </blockquote> <h4>总结</h4> <ul> <li><strong>watchEffect</strong>不需要指定监听的属性，他会自动的收集依赖，只要在回调函数中引用到了响应式的属性，那么当这些属性变动的时候，这个回调都会执行，而<strong>watch</strong>只能监听指定的属性而作出变动(vue3开始能够同时指定多个)</li> <li><strong>watch</strong>能够获取到新值与旧值（更新前的值），而<strong>watchEffect</strong>是拿不到的</li> <li><strong>watchEffect</strong>在组件初始化的时候就会执行一次用以收集依赖，收集到的依赖发生变化时再执行。而<strong>watch</strong>则是直接指定依赖项</li> </ul> <h3>methods</h3> <p><strong>基础用法</strong></p> <pre><code>// 模版 <p>Capacity: {<!-- -->{capacity}}</p> <button @click="increaseCapacity()">Increase Capacity</button>    // script setup{ 	const capacity = ref(3);   function increaseCapacity(){    capacity.value++   }   return {   	capacity,   	increaseCapacity   } }</code></pre> <h1>存在的问题</h1> <p>当然Composition API的引入也存在一定的弊端，组合式API在代码组织方面提供了更多的灵活性，但它也需要开发人员更多地遵守约定（即正确的使用方法），组合式API会让使用不熟的人编写出面条代码：</p> <p><strong>什么是面条代码？</strong></p> <p>代码的控制结构复杂、混乱，逻辑不清，关系耦合，让人一时难以理解</p> <p><strong>为什么会出现面条代码？</strong></p> <p>在Options API 中实际上形成了一种强制的约定：</p> <ul> <li> <p>props里面设置接收参数</p> </li> <li> <p>data 里面设置变量</p> </li> <li> <p>computed里面设置计算属性</p> </li> <li> <p>watch里面设置监听属性</p> </li> <li> <p>methods里面设置事件方法</p> </li> </ul> <p>我们发现Options API已经约定了我们该在哪个位置做什么事，这在一定程度上也强制我们进行了代码分割。 现在用Composition API，不再这么约定了，于是代码组织非常灵活，如果作为一个新手，或者不深入思考的话，那么在逻辑越来越复杂的情况下，setup代码量越来越多，同样setup里面的return越来越复杂，那么肯定会成为面条代码。</p> <p><strong>如何避免？</strong></p> <p>没有了this上下文，没有了Options API的强制代码分离。Composition API给了更加广阔的天地，那么我们需要慎重自约起来。牢记<code>setup()</code>函数现在只是简单地作为调用所有组合函数的入口。即对于复杂的逻辑代码，我们要更加重视起 Composition API的初心，使用Composition API来分离代码，用来切割成各种模块导出。</p> <p>即我们期望的代码是长下面这样的，这样就算setup内容代码量越来越大，但是始终代码结构清晰。</p> <pre><code>import useA from './a'; import useB from './b';  export default {     setup (props) {         let { a, methodsA } = useA();         let { b, methodsB } = useB();         return {             a,             methodsA,             b,             methodsB,         }     } }</code></pre> <h1>Composition API实现逻辑复用</h1> <h2>规则</h2> <ul> <li><code>Composition API</code> 指<strong>抽离逻辑代码到一个函数</strong></li> <li>函数的命名约定为<code>useXxxx</code>格式</li> <li>在<code>setup</code>中引用<code>useXxx</code>函数</li> </ul> <h2>Demo</h2> <p>引用一个非常经典的例子：获取鼠标的定位，我们用Composition API来进行封装演示</p> <pre><code>// useMousePosition.js import { ref, onMounted, onUnmounted } from 'vue' function useMousePosition() {     const x = ref(0)     const y = ref(0)      function update(e) {         x.value = e.pageX         y.value = e.pageY     }      onMounted(() => {         console.log('useMousePosition mounted')         window.addEventListener('mousemove', update)     })      onUnmounted(() => {         console.log('useMousePosition unMounted')         window.removeEventListener('mousemove', update)     })      return {         x,         y     } }  export default {   useMousePosition }  // .vue文件 <template>     <p v-if="flag">mouse position {<!-- -->{x}} {<!-- -->{y}}</p>     <button @click="changeFlagHandler">change flag</button> </template>  <script> import { reactive } from 'vue' import utils from "../../utils/useMousePosition";  export default {     name: 'MousePosition',     setup() {         const { x, y } = utils.useMousePosition();         let flag = ref(true);         console.log(flag, "----");         let changeFlagHandler = () => {           flag.value = !flag.value;         };         return {             x,             y,             flag,       			changeFlagHandler,         }     } } </script></code></pre> <p>参考网址：<br /> https://www.vue3js.cn/docs/zh/api/composition-api.html#setup</p> <p>https://juejin.cn/post/6890545920883032071 (动画)</p> </div> 			
                    <div class="col-md-12 mt-5">
                                                <p>上一个：<a href="/html/category/article-787.htm">微服务架构学习与思考(09)：分布式链路追踪系统-dapper论文学习</a></p>
                                                <p>下一个：<a href="/html/category/article-793.htm">Java中线程状态+线程安全问题+synchronized的用法详解_java_</a></p>
                                            </div>

                                    </div>
                <div class="col-md-3">
                	<div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title">热门文章</h3>
    </div>
    <div class="panel-body">
        <ul class="p-0 x-0" style="list-style: none;margin: 0;padding: 0;">
                        <li class="py-2"><a href="/html/category/article-6986.htm" title="什么牌子的蟑螂药最管用(什么牌子的蟑螂药最管用最好)">什么牌子的蟑螂药最管用(什么牌子的蟑螂药最管用最好)</a></li>
                        <li class="py-2"><a href="/html/category/article-6940.htm" title="为什么常熟羊毛羊绒大衣这两年发展得这么好呢(常熟的羊绒大衣批发在哪里)">为什么常熟羊毛羊绒大衣这两年发展得这么好呢(常熟的羊绒大衣批发在哪里)</a></li>
                        <li class="py-2"><a href="/html/category/article-6020.htm" title="宠物疫苗能带上高铁吗国内（宠物疫苗可以过安检吗）">宠物疫苗能带上高铁吗国内（宠物疫苗可以过安检吗）</a></li>
                        <li class="py-2"><a href="/html/category/article-6065.htm" title="动物医院大众点评评语大全集怎么写（动物医院好评）">动物医院大众点评评语大全集怎么写（动物医院好评）</a></li>
                        <li class="py-2"><a href="/html/category/article-7309.htm" title="小型颗粒饲料机价格多少（小型颗粒饲料机价格多少钱）">小型颗粒饲料机价格多少（小型颗粒饲料机价格多少钱）</a></li>
                        <li class="py-2"><a href="/html/category/article-6573.htm" title="领养宠物协议书范本大全最新图片（领养宠物协议书范本大全最新图片高清）">领养宠物协议书范本大全最新图片（领养宠物协议书范本大全最新图片高清）</a></li>
                        <li class="py-2"><a href="/html/category/article-7308.htm" title="动物疫苗注射的作用是什么呢（动物 疫苗）">动物疫苗注射的作用是什么呢（动物 疫苗）</a></li>
                        <li class="py-2"><a href="/html/category/article-7354.htm" title="宠物猫驱虫多少钱一次喵旺清虫（喵汪清宠驱虫药）">宠物猫驱虫多少钱一次喵旺清虫（喵汪清宠驱虫药）</a></li>
                        <li class="py-2"><a href="/html/category/article-6848.htm" title="动物疫苗的使用方法视频（动物疫苗的使用方法及注意事项）">动物疫苗的使用方法视频（动物疫苗的使用方法及注意事项）</a></li>
                        <li class="py-2"><a href="/html/category/article-5933.htm" title="动物打完疫苗可以洗澡吗有影响吗知乎（动物打疫苗后多久能杀了吃）">动物打完疫苗可以洗澡吗有影响吗知乎（动物打疫苗后多久能杀了吃）</a></li>
                    </ul>
    </div>
</div>

<div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title">归纳</h3>
    </div>
    <div class="panel-body">
        <ul class="p-0 x-0" style="list-style: none;margin: 0;padding: 0;">
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">20</span> <a href="/html/date/2024-08/" title="2024-08 归档">2024-08</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">62</span> <a href="/html/date/2024-07/" title="2024-07 归档">2024-07</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">60</span> <a href="/html/date/2024-06/" title="2024-06 归档">2024-06</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">62</span> <a href="/html/date/2024-05/" title="2024-05 归档">2024-05</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">60</span> <a href="/html/date/2024-04/" title="2024-04 归档">2024-04</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">62</span> <a href="/html/date/2024-03/" title="2024-03 归档">2024-03</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">54</span> <a href="/html/date/2024-02/" title="2024-02 归档">2024-02</a></h4>
            </li>
                    </ul>
    </div>
</div>

                </div>
            </div>
        </div>
    </section>
        <footer class="ftco-footer ftco-section">
        <div class="container">
            <div class="row">
                <div class="col-md-12 text-center">
                    <p>
                        FinlandAddress 版权所有
                        <br />
                        Powered by WordPress
                    </p>
                </div>
            </div>
        </div>
    </footer>
    <!-- loader -->
    <div id="ftco-loader" class="show fullscreen"><svg class="circular" width="48px" height="48px">
            <circle class="path-bg" cx="24" cy="24" r="22" fill="none" stroke-width="4" stroke="#eeeeee" />
            <circle class="path" cx="24" cy="24" r="22" fill="none" stroke-width="4" stroke-miterlimit="10" stroke="#F96D00" /></svg></div>
    <script src="/assets/addons/xcblog/js/frontend/finlandaddress/jquery.min.js"></script>
    <script src="/assets/addons/xcblog/js/frontend/finlandaddress/jquery-migrate-3.0.1.min.js"></script>
    <script src="/assets/addons/xcblog/js/frontend/finlandaddress/popper.min.js"></script>
    <script src="/assets/addons/xcblog/js/frontend/finlandaddress/bootstrap.min.js"></script>
    <script src="/assets/addons/xcblog/js/frontend/finlandaddress/jquery.easing.1.3.js"></script>
    <script src="/assets/addons/xcblog/js/frontend/finlandaddress/jquery.waypoints.min.js"></script>
    <script src="/assets/addons/xcblog/js/frontend/finlandaddress/jquery.stellar.min.js"></script>
    <script src="/assets/addons/xcblog/js/frontend/finlandaddress/owl.carousel.min.js"></script>
    <script src="/assets/addons/xcblog/js/frontend/finlandaddress/jquery.magnific-popup.min.js"></script>
    <script src="/assets/addons/xcblog/js/frontend/finlandaddress/jquery.animateNumber.min.js"></script>
    <script src="/assets/addons/xcblog/js/frontend/finlandaddress/scrollax.min.js"></script>
    <script src="/assets/addons/xcblog/js/frontend/finlandaddress/main.js"></script>
    <script>
    $(function() {
        $('.js_to').click(function(){
            var url = $(this).data('url');
            var code = $(this).data('code');
            url += code;

            window.open(url);
        })
    });
    </script>
</body>

</html>